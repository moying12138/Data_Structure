### **题目    36. 有效的数独**

#### 题目描述
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
![Alt text](./1534497785396.png)
上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。
#### 示例 1:
```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```
#### 示例 2:
```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```
**说明:**
   - 一个有效的数独（部分已被填充）不一定是可解的。
   - 只需要根据以上规则，验证已经填入的数字是否有效即可。
   -  给定数独序列只包含数字 1-9 和字符 '.' 。
   - 给定数独永远是 9x9 形式的。


#### 解析
1. 这题首先想到的就是三次遍历, (行, 列, 和 3 * 3 的遍历) ,会每个元素遍历三次
2. 然后就有下面的做法, 每个元素只遍历了一次, 当我遍历一个数的时候,其实我已经知道他的所在的位置(行, 列, 3* 3 的位置), 然后就开一个可以存下 (行,列 3 * 3) 3种状态的二维数组, 当遍历到这个数时, 和之前的数组中元素比较,没有就把它存到数组中相应的位置, 有就范会false.
#### 代码
```
bool isValidSudoku(char** board, int boardRowSize, int boardColSize) {
    int temp[27][10] = {0};
    for(int i = 0; i < boardRowSize; ++i) {
        for(int j = 0; j < boardColSize; ++j) {
            if(board[i][j] == '.') continue;
            int ind = board[i][j] - '0';
            printf("%d ", ind);
            if(temp[i][ind]) return false;
            temp[i][ind] = 1;
            if(temp[j + 9][ind]) return false;
            temp[j + 9][ind] = 1;
            int x = (i / 3) * 3 + j / 3 + 18;
            if(temp[x][ind]) return false;
            temp[x][ind] = 1;
        }
    }
    return true;
}
```

























